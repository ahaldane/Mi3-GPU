
Mi-3-GPU User Guide
===================

Mi3-GPU (Mee-three) solves the "inverse Ising problem" using a GPU-parallelized Monte-Carlo sequence generation algorithm, to infer Potts models for analyzing coevolutionary mutation patterns in Multiple Sequence Alignements.

 * Installation
 * Overview
 * Tutorial
 * File Formats
 * Usage and Options

Installation and Requirements
-----------------------------

Requirements: 

 * Python3 with scipy, numpy, PyOpenCL, and BioPython. 
 * OpenCL drivers, ideally with multiple fast GPUs
 * mwc64x (see below)
 * gcc (for helper utils only)
 * Optional: mpi4py

After cloning this repository, download the `mwc64x` software (available at http://cas.ee.ic.ac.uk/people/dt10/research/rngs-gpu-mwc64x.html) and place it in the directory named `mwc64x` next to the `Mi3.py` script.

The helper module "seqtools" in the utils directory must be compiled with `make seqtools` (requires gcc). 

To check that the script is correctly detecting the system's OpenCL installation and GPUs, run:

    ./Mi3.py --clinfo

which should output information on the available GPUs. XXX with MPI

Overview of Functionality
-------------------------

The `Mi3.py` script can be run in a variety of modes:

 * `infer` : Perform inverse Ising inference of a Potts model given bivariate marginals
 * `gen` : Generate new sequences given a Potts model
 * `energies` : Compute Potts energies of sequences in an MSA
 * `bimarg` : Compute bivariate residue frequencies (marginals) of an MSA
 * `subseq` : Estimate long subsequences frequencies
 * `benchmark` : Estimate computational speed of the MCMC generation

The mode is given as first argument to `Mi3.py`. To see further options for each mode, use the `-h` option:

    ./Mi3.py infer -h

A number of additional helper scripts are available in the `utils` directory
which are used for pre- and post- processing of MSAs and Potts model files.
The main ones are:

 * `changeGauge.py` : Contains methods for transforming a Potts model between different gauges.
 * `phyloWeights.py` : Efficiently compute phylogenetic weights for an MSA using the standard downweighting strategy used in covariation analysis.
 * `pseudocount.py` : Apply the small-sample pseudocount to a bivariate marginal file
 * `pre_regularize.py` : Apply a regularization pseudocount to a bivariate marginal file
 * `getSeqBimarg.py` : Compute bivariate residue frequencies for an MSA (with weights)
 * `getSeqEnergies.py` : Compute Potts energies for sequences in an MSA
 * `exploreParam.py` : Visualize the Potts model
 * `alphabet_reduction.py` : Find reduction from 21 letters to fewer for and MSA.
 * `apply_alphamap.py` : Given an alphabt mapping, convert an MSA to the reduced alphabet.

It is useful to understand the stages of the inverse Ising inference in Mi3 in order to set options. After initial startup, there are two alternating phases: 1. An MCMC sequence-generation phase in which a synthetic MSA is generated from a trial Potts model. 2. A parameter update phase, in which the Potts parameters are updated based on the discrepancy between the simulated marginals and the dataset marginals you supplied.

Tutorial
--------

Inverse Ising Inference
~~~~~~~~~~~~~~~~~~~~~~~

A PBS script showing a typical set of arguments for inverse Ising inference is in the file `example/HIV_inference/pbs.sh`. When executed in its directory, this script will fit a Potts model to the bivariate marginals from the file `example_bimarg_pc.npy` (obtained from an HIV dataset for sequences of length length 93 with 4 residue types) and put the results in a directory `hiv_pr_inference`. The log file `hiv_pr_inference.log` contains details about how the program is running. To monitor progress, a tip is to do `grep Error hiv_pr_inference.log`.

You initially need to supply a bivariate marginal file (`--bim`), an initial trial Potts model (`--J`), an output directory (`--outdir`), the sequence alphabet (`--alpha`) and the synthetic MSA size (`--nwalkers`), but may later want to modify other options from their defaults. See "helper scripts" below on how to generate a bivariate marginal file from an MSA.

Sequence Generation Arguments
.............................

One set of options controls how synthetic MSAs are generated. `--nwalkers` is the most important as it controls the size of the generated MSA, which is a main determinant of the level of statistical error (see discussion in PRE). The synthetic MSA is generated by having each GPU work-unit perform MCMC on a single sequence, "walking" that sequence through sequence space until equilibrium is reached. It is best to make `--nwalkers` a power of 2 to optimize GPU occupancy. As discussed in PRE. For most proteins it is desirable to use large synthetic MSAs, and we recommended at minimum 2^15 (32768), and have commonly used 2^20 and 2^22 particularly when refining a model which is already well optimized. Larger values also make better use of GPU resources (latency hiding).

The next useful argument is `--reseed`, which controls how the GPU work-unit sequences are initialized in each round of MCMC sequence generation. In the MSA generation phase, Mi3 runs the GPU walkers until it detects that Markov equilibrium is reached, which it does by measuring the time-autocorrelation of the sequence energies. Ideally, how the walkers are initialized should not matter, but in pathological cases (eg, golf course landscapes, rugged/glassy phases) it can. One option is to reset all walkers to the same sequence, which may either be random (`single_random`), generated by an independent model (`single indep`), or taken from previously generated sequences (`single_best`). One can also not reset the sequences between rounds (`none`), reset to to sequences from a provided MSA (`msa`) specified with the `--seedmsa` option, or reset to sequences generated by the independent model (`independent`). We recommend either `single_indep` (the default) because it helps highlight pathological behavior by starting off in a highly nonequilibrium state, or to reseed with sequences from the dataset MSA, as these are likely to already be energy minima in the Potts landscape due to overfitting effects (see PRE) and this overfitting can then be observed by a failure to reach equilibrium.



The `seqmodel` argument is "intelligent": If set to the string 'independent' it will initialize the coupling values accorging to the uncorrelated (logscore) model and generate corresponding initial sequences. It may also be set to a directory containing the output of a previous run from which it will load the couplings and sequences. 


Potts Parameter Fitting Arguments
.................................

Once a synthetic MSA has been generated using the trial set of coupling parameters, Mi3 enters into a parameter update phase. 

distribute_jstep


MSA preprocessing helper-scripts
................................

Helper scripts are also included: 
 * `getSeqBimarg.py` and `getSeqEnergies.py` compute bivariate marginals and sequence statistical energies given an MSA (and Potts couplings, for energies).
 * `pseudocount.py` adds different forms of pseudocount to the bivariate marginals.
 * `phyloWeights.py` computes the weights to account for phylogenetic relationships between sequences in an MSA, using the weighting strategy described in most covariation studies.
 * `alphabet_reduction.py` reduces the 20-letter amino acid alphabet (plus gap) to a reduced alphabet, in a way which preserves the MSA correlations. `apply_alphamap.py` applies this mapping to an MSA.
 * `changeGauge.py` transforms the Potts parameters between different gauges.

Most of these scripts expect MSA files formatted to contain only the aligned sequences, one sequence per line. You must convert any FASTA files to this format yourself, by stripping the sequence header lines and joining the sequences into one line each, which can be achieved using the BioPython module, for example, or by simple shell commands. 

Most testing has been done on Nvidia graphics cards. It is confirmed to run on systems with Nvidia Tesla K80, P100, and V100 and GTX 580 and Titan X, with 4 GPUs per node.


File Formats
............

The Potts model coupling files and the bivariate marginal files are stored in the `npy` data format as 2-dimensional `float32` arrays of dimension `(L*(L-1)/2, q*q)`. The first dimension corresponds to position-pairs i,j, ordered as in the python code `[(i,j) for i in range(L-1) for j in range(i+1,L)]`, i.e in order `(0,1), (0,2), (0,3) ... (1,2), (1,3) ...`. The second dimension corresponds to residue (letter) pairs, ordered as in `[(a+'i', b+'j') for a in alpha for b in alpha]` for alphabet string `alpha`.

The Potts couplings are stored according to the following sign conventions: `P(S) = exp(-E(S))`, `E(S) = \sum_{ij} J^{ij}_{s_i s_j}`.

GIIIM performs almost all calculations in a "fieldless" gauge, so in general the couplings file fully specifies the model and no fields are needed. However, someme programs such as the `changeGauge.py` script can output fields, and these are output as a 2-dimensional `float32` array of dimension `(L, q)`.

MSAs are stored in a custom format to help optimize writing to and from disk, which is simply the ASCII sequences, one sequence per line, with all sequence ID information stripped. The sequences must have the same length. These MSA files can sometimes contain header lines starting with `#`. In some cases GIIIM outputs sequence files compressed with bzip2.
